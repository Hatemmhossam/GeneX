# -*- coding: utf-8 -*-
"""DigitalTwinn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x5TLdXsX41hnMd5vy2khRMyP37VODPfq
"""

import torch
import torch.nn as nn
import pandas as pd
import numpy as np
import requests
import random
import matplotlib.pyplot as plt

from sklearn.preprocessing import RobustScaler
from sklearn.metrics import accuracy_score, confusion_matrix


device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

SEED = 42

random.seed(SEED)
np.random.seed(SEED)
torch.manual_seed(SEED)
torch.cuda.manual_seed_all(SEED)

torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False

"""Autoencoder"""

class DenoisingAE(nn.Module):
    def __init__(self, input_dim, latent_dim=32):
        super().__init__()

        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 256),
            nn.ReLU(),
            nn.Linear(256, latent_dim)
        )

        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, 256),
            nn.ReLU(),
            nn.Linear(256, input_dim)
        )

    def forward(self, x):
        z = self.encoder(x)
        x_hat = self.decoder(z)
        return x_hat, z

"""Drug-gene mapping"""

def fetch_drug_targets(drugs):

    url = "https://dgidb.org/api/graphql"

    query = """
    query GetInteractions($drugs: [String!]!) {
      drugs(names: $drugs) {
        nodes {
          name
          interactions {
            gene { name }
          }
        }
      }
    }
    """

    response = requests.post(
        url,
        json={"query": query, "variables": {"drugs": drugs}}
    )

    data = response.json()

    mapping = {}

    for node in data["data"]["drugs"]["nodes"]:
        mapping[node["name"].upper()] = list(
            {i["gene"]["name"] for i in node["interactions"]}
        )

    return mapping

"""pathways"""

PATHWAYS = {
    "Inflammatory_Response": ["IL6", "TNF", "STAT3", "JAK1"],
    "T_Cell_Activation": ["FOXP3", "CD28", "IL2RA"],
    "Antigen_Presentation": ["HLA-B", "HLA-DPB1", "HLA-DQB1"],
}

class DigitalTwin:
    def __init__(self, gene_cols, healthy_tensor, drugs):
        self.gene_cols = gene_cols
        self.idx = {g:i for i,g in enumerate(gene_cols)}
        self.healthy_ref = healthy_tensor.mean(0, keepdim=True).to(device)
        print(" Fetching live drug targets from DGIdb...") # Uncommented
        self.drug_map = fetch_drug_targets(drugs) # Uncommented

    def risk(self, model, x):
        with torch.no_grad():
            x_hat,_ = model(x)
        return torch.mean((x_hat - x)**2).item()

    def pathway_hits(self, targets):
        out = {}
        for name, genes in PATHWAYS.items():
            hits = set(targets).intersection(genes)
            if hits:
                out[name] = round(len(hits)/len(genes)*100,1)
        return out

    def gene_changes(self, before, after, targets, top_k=10):
        changes = []
        for g in targets:
            if g not in self.idx: continue
            i = self.idx[g]
            b = before[0,i].item()
            a = after[0,i].item()
            h = self.healthy_ref[0,i].item()
            direction = "✅ Good" if abs(a-h)<abs(b-h) else "❌ Bad"
            changes.append((g,b,a,direction))
        changes.sort(key=lambda x: abs(x[1]-x[2]), reverse=True)
        return changes[:top_k]

    def evaluate_patient(self, model, patient):
        baseline = self.risk(model, patient)

        summary = []            # for summary table
        detailed_results = []   # for detailed drug info

        # Compute drug effects

        for drug, targets in self.drug_map.items():
            valid = [t for t in targets if t in self.idx]
            if not valid: continue

            after = patient.clone()
            for g in valid:
                after[0,self.idx[g]] *= 0.3

            after_risk = self.risk(model, after)
            reduction = (baseline - after_risk)/baseline*100

            pathways = self.pathway_hits(valid)
            top_pathway = max(pathways, key=lambda k: pathways[k]) if pathways else "None"

            # Recommendation
            if reduction>0.1: status = "✅ Recommended"
            elif reduction>0: status = "⚠️ Low Impact"
            else: status = "❌ Not suitable"

            summary.append({"Drug":drug,"Risk_Reduction":round(reduction,3),"Status":status})
            detailed_results.append({
                "Drug": drug,
                "Risk_Reduction": round(reduction,3),
                "Top_Pathway": top_pathway,
                "Pathways": pathways,
                "Gene_Changes": self.gene_changes(patient, after, valid),
                "Status": status
            })

        # Print summary table

        df_summary = pd.DataFrame(summary)
        df_summary = df_summary.sort_values(by="Risk_Reduction", ascending=False).reset_index(drop=True)

        print("\n" + "="*80)
        print("PRECISION MEDICINE REPORT")
        print("="*80)
        header = f"{'Drug':<12} {'Risk_Reduction':>15} {'Status':>15}"
        print(header)
        print("-"*80)

        for idx, row_data in df_summary.iterrows():
            row_str = f"{row_data['Drug']:<12} {row_data['Risk_Reduction']:>15.3f}% {row_data['Status']:>15}"
            print(row_str)
        print("="*80)

        # best drug

        best_drug = df_summary.iloc[0]
        print(f"\n BEST DRUG: {best_drug['Drug']}  |  Risk Reduction: {best_drug['Risk_Reduction']:.3f}%  |  Status: {best_drug['Status']}")
        print("="*80)

        #  Detailed drug info

        for res in detailed_results:
            print(f"\n Drug: {res['Drug']}")
            print(f"Risk Reduction: {res['Risk_Reduction']:.3f}%")
            print(f"Top Pathway: {res['Top_Pathway']}")
            print("Top gene changes:")
            for g,b,a,d in res['Gene_Changes']:
                print(f"  {g}: {b:.2f} → {a:.2f} {d}")
            print(f"Status: {res['Status']}")


        #  Plot risk reduction

        import matplotlib.pyplot as plt

        plt.figure(figsize=(8,5))
        plt.bar(df_summary["Drug"], df_summary["Risk_Reduction"], color="skyblue")
        plt.ylabel("Risk Reduction (%)")
        plt.title("Drug Risk Reduction")
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

f = pd.read_csv("/content/drive/MyDrive/master_df/master_df.csv")

gene_cols = [c for c in df.columns if c not in ["Label", "Batch"]]

df["Label_num"] = (df["Label"]!="Healthy").astype(int)

scaler = RobustScaler()
X = scaler.fit_transform(df[gene_cols])

X_tensor = torch.tensor(X, dtype=torch.float32).to(device)
y = df["Label_num"].values

healthy_tensor = X_tensor[y==0]

model = DenoisingAE(len(gene_cols)).to(device)

opt = torch.optim.Adam(model.parameters(), lr=1e-3)
loss_fn = nn.MSELoss()

print(" Training patient twin...")

for epoch in range(150):

    noise = 0.05*torch.randn_like(healthy_tensor)
    out,_ = model(healthy_tensor+noise)

    loss = loss_fn(out, healthy_tensor)

    opt.zero_grad()
    loss.backward()
    opt.step()

    if epoch%20==0:
        print("Epoch",epoch,"Loss:",round(loss.item(),4))

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

#  Compute risks
risks = [torch.mean((model(p.unsqueeze(0))[0]-p.unsqueeze(0))**2).item() for p in X_tensor]
risks_np = np.array(risks)

# Candidate thresholds
thresholds = np.linspace(risks_np.min(), risks_np.max(), 1000)

#  Track metrics for each threshold
precisions = []
recalls = []
f1s = []
accuracies = []

min_precision = 0.998  # Constraint

for t in thresholds:
    pred = [1 if r > t else 0 for r in risks_np]
    prec = precision_score(y, pred, zero_division=1)
    rec = recall_score(y, pred)
    f1 = f1_score(y, pred)
    acc = accuracy_score(y, pred)

    # Only consider thresholds that satisfy precision constraint
    if prec >= min_precision:
        precisions.append(prec)
        recalls.append(rec)
        f1s.append(f1)
        accuracies.append(acc)
    else:
        # Fill with NaN so we can see where precision drops
        precisions.append(np.nan)
        recalls.append(np.nan)
        f1s.append(np.nan)
        accuracies.append(np.nan)

# ---- Convert to numpy
precisions = np.array(precisions)
recalls = np.array(recalls)
f1s = np.array(f1s)
accuracies = np.array(accuracies)

# ---- Find best F1 under precision constraint
valid_indices = ~np.isnan(f1s)
best_idx = np.argmax(f1s[valid_indices])
best_threshold = thresholds[valid_indices][best_idx]

# ---- Metrics at best threshold
pred_best = [1 if r > best_threshold else 0 for r in risks_np]
acc_best = accuracy_score(y, pred_best)
prec_best = precision_score(y, pred_best)
rec_best = recall_score(y, pred_best)
f1_best = f1_score(y, pred_best)
cm_best = confusion_matrix(y, pred_best)

print(f"Best Threshold : {best_threshold:.5f}\n")
print(" Health Detector Metrics: ")
print("="*50)
# print(f"Best Threshold : {best_threshold:.5f}")
print(f"Accuracy       : {acc_best:.3f}")
print(f"Precision      : {prec_best:.3f}")
print(f"Recall         : {rec_best:.3f}")
print(f"F1-score       : {f1_best:.3f}")

# ---- Plot metrics vs thresholds
plt.figure(figsize=(10,6))
plt.plot(thresholds, precisions, label="Precision", color="blue")
plt.plot(thresholds, recalls, label="Recall", color="orange")
plt.plot(thresholds, f1s, label="F1-score", color="green")
plt.axvline(best_threshold, color="red", linestyle="--", label=f"Best Threshold ({best_threshold:.3f})")
plt.xlabel("Threshold")
plt.ylabel("Metric Value")
plt.title("Metric vs Threshold ")
plt.legend()
plt.grid(True)
plt.show()

# ---- Risk histogram with best threshold
plt.figure(figsize=(8,5))
plt.hist([risks_np[y==0], risks_np[y==1]], bins=50, color=["skyblue","orange"], alpha=0.7, label=["Healthy","Sick"])
plt.axvline(best_threshold, color="red", linestyle="--", label=f"Best Threshold ({best_threshold:.3f})")
plt.title("Risk Distribution")
plt.xlabel("Reconstruction Error (Risk)")
plt.ylabel("Number of Patients")
plt.legend()
plt.show()

# ---- Confusion matrix heatmap
plt.figure(figsize=(5,4))
plt.imshow(cm_best, cmap="Blues")
plt.colorbar()
plt.title("Confusion Matrix")
plt.xticks([0,1], ["Healthy","Sick"])
plt.yticks([0,1], ["Healthy","Sick"])
for i in range(cm_best.shape[0]):
    for j in range(cm_best.shape[1]):
        plt.text(j, i, str(cm_best[i,j]), ha="center", va="center", color="black", fontsize=12)
plt.show()

patient_id = 30

patient_tensor = X_tensor[patient_id:patient_id+1]

drugs = ["Adalimumab","Infliximab","Tofacitinib","Abatacept","Tocilizumab"]

twin = DigitalTwin(gene_cols, healthy_tensor, drugs)

twin.evaluate_patient(model, patient_tensor)
